#!/usr/bin/env php
<?php

$argObj = new Args($_SERVER['argv']);

// Action dispatch - one class per action
$actionClass = 'Action_'.strtolower($argObj->getAction());
if(class_exists($actionClass)) {
	$obj = new $actionClass;
	try {
		$obj->go($argObj, new Executor);
	} catch(Exception $e) {
		echo $e->getMessage() . "\n";
		exit(4);
	}
} else {
	echo "Unrecognised action '" . $argObj->getAction() . "'.\n";
	exit(3);
}

exit(0);

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Handles argument processing
 */
class Args {
	protected $namedArgs = array();
	protected $unnamedArgs = array();
	protected $action = null;

	function __construct($args) {
		array_shift($args);

		foreach($args as $arg) {
			if(preg_match('/^--([^=]+)=(.*)$/', $arg, $matches)) {
				$this->namedArgs[$matches[1]] = $matches[2];
			} else if(preg_match('/^--([^=]+)$/', $arg, $matches)) {
				$this->namedArgs[$matches[1]] = true;
			} else {
				$this->unnamedArgs[] = $arg;
			}
		}

		if(sizeof($this->unnamedArgs) != 3) {
			echo "Usage: {$_SERVER['argv'][0]} (action) (from) (to)\n\nAction can be 'save', 'load', or 'transfer'.\n";
			exit(1);
		}

		$this->action = array_shift($this->unnamedArgs);
	}

	function getNamedArgs() {
		return $this->namedArgs;
	}

	function getUnnamedArgs() {
		return $this->unnamedArgs;
	}

	function getAction() {
		return $this->action;
	}

	/**
	 * Return the unnamed arg of the given index (0 = first)
	 */
	function unnamed($idx) {
		return $this->unnamedArgs[$idx];
	}

	/**
	 * Return the sudo argument, preferring a more specific one with the given optional prefix
	 */
	function sudo($optionalPrefix) {
		if(!empty($this->namedArgs[$optionalPrefix . '-sudo'])) return $this->namedArgs[$optionalPrefix . '-sudo'];
		else if(!empty($this->namedArgs['sudo'])) return $this->namedArgs['sudo'];
		else return null;
	}

	/**
	 * Return the pak-parks arguments, as a map of part => boolean
	 */
	function pakParts() {
		// Look up which parts of the sspak are going to be saved
		$pakParks = array();
		foreach(array('assets','db') as $part) {
			$pakParts[$part] = !empty($this->namedArgs[$part]);
		}
		// Default to db and assets
		if(!array_filter($pakParts)) $pakParts = array('db' => true, 'assets' => true);
		return $pakParts;
	}

}

/**
 * Save an .sspak file
 */
class Action_save {
	function go($args, $executor) {
		$unnamedArgs = $args->getUnnamedArgs();
		$namedArgs = $args->getNamedArgs();

		$webroot = new Webroot($unnamedArgs[0], $executor);
		$file = $unnamedArgs[1];
		$sspak = new SSPakFile($file, $executor);

		if(!empty($namedArgs['from-sudo'])) $webroot->setSudo($namedArgs['from-sudo']);
		else if(!empty($namedArgs['sudo'])) $webroot->setSudo($namedArgs['sudo']);

		// Look up which parts of the sspak are going to be saved
		$pakParks = array();
		foreach(array('assets','db','git-remote') as $part) {
			$pakParts[$part] = !empty($namedArgs[$part]);
		}
		// Default to db and assets
		if(!array_filter($pakParts)) $pakParts = array('db' => true, 'assets' => true, 'git-remote' => true);

		// Get the environment details
		$details = $webroot->sniff();

		if(file_exists($file)) throw new Exception( "File '$file' already exists.");

		// Create a build folder for the sspak file
		$buildFolder = "/tmp/sspak-" . rand(100000,999999);
		$webroot->exec(array('mkdir', $buildFolder));

		$dbFile = "$buildFolder/database.sql.gz";
		$assetsFile = "$buildFolder/assets.tar.gz";
		$gitRemoteFile = "$buildFolder/git-remote";

		// Files to include in the .sspak file
		$fileList = array();

		// Save DB
		if($pakParts['db']) {
			// Check the database type
			$dbFunction = 'getdb_'.$details['db_type'];
			if(!method_exists($this,$dbFunction)) {
				throw new Exception("Can't process database type '" . $details['db_type'] . "'");
			}
			$this->$dbFunction($webroot, $details, $dbFile);
			$fileList[] = basename($dbFile);
		}

		// Save Assets
		if($pakParts['assets']) {
			$this->getassets($webroot, $details['assets_path'], $assetsFile);
			$fileList[] = basename($assetsFile);
		}

		// Save git-remote
		if($pakParts['git-remote']) {
			if($this->getgitremote($webroot, $gitRemoteFile)) {
				$fileList[] = basename($gitRemoteFile);
			}
		}

		// Create the sspak file
		$webroot->exec(
			array_merge(array('tar', '-C', $buildFolder, '-c', '-f','-'), $fileList),
			array('outputFile' => $file)
		);
		
		// Remove the build folder
		$webroot->unlink($buildFolder);
	}

	function getdb_MySQLDatabase($webroot, $conf, $filename) {
		$usernameArg = escapeshellarg("--user=".$conf['db_username']);
		$passwordArg = escapeshellarg("--password=".$conf['db_password']);
		$databaseArg = escapeshellarg($conf['db_database']);
		$hostArg = (!empty($conf['db_server']) && $conf['db_server'] != 'localhost') ? escapeshellarg("--host=".$conf['db_server']) : '';
		$filenameArg = escapeshellarg($filename);

		return $webroot->exec("mysqldump --skip-opt --add-drop-table --extended-insert --create-options --quick  --set-charset --default-character-set=utf8 $usernameArg $passwordArg $hostArg $databaseArg | gzip -c > $filenameArg");
	}

	function getdb_PostgreSQLDatabase($webroot, $conf, $filename) {
		$usernameArg = escapeshellarg("--username=".$conf['db_username']);
		$passwordArg = "PGPASSWORD=".escapeshellarg($conf['db_password']);
		$databaseArg = escapeshellarg($conf['db_database']);
		$hostArg = escapeshellarg("--host=".$conf['db_server']);
		$filenameArg = escapeshellarg($filename);

		return $webroot->exec("$passwordArg pg_dump --clean $usernameArg $hostArg $databaseArg | gzip -c > $filenameArg");
	}

	function getassets($webroot, $assetsPath, $filename) {
		$assetsParentArg = escapeshellarg(dirname($assetsPath));
		$assetsBaseArg = escapeshellarg(basename($assetsPath));
		$filenameArg = escapeshellarg($filename);

		return $webroot->exec("cd $assetsParentArg && tar czf $filenameArg $assetsBaseArg");
	}

	function getgitremote($webroot, $gitRemoteFile) {
		// Only do anything if we're copying from a git checkout
		$gitRepo = $webroot->getPath() .'/.git';
		if($webroot->exists($gitRepo)) {
			// Identify current branch
			$output = $webroot->exec(array('git', '--git-dir='.$gitRepo, 'branch'));
			if(preg_match("/\* ([^ \n]*)/", $output['output'], $matches)) {
				// If there is a current branch, use that branch's remove
				$currentBranch = $matches[1];
				$output = $webroot->exec(array('git', '--git-dir='.$gitRepo, 'config','--get',"branch.$currentBranch.remote"));
				$remoteName = trim($output['output']);
				if(!$remoteName) $remoteName = 'origin';

			// Default to origin
			} else {
				$currentBranch = null;
				$remoteName = 'origin';	
			}

			// Determine the URL of that remote
			$output = $webroot->exec(array('git', '--git-dir='.$gitRepo, 'config','--get',"remote.$remoteName.url"));
			$remoteURL = trim($output['output']);

			// Determine the current SHA
			$output = $webroot->exec(array('git', '--git-dir='.$gitRepo, 'log','-1','--format=%H'));
			$sha = trim($output['output']);

			$content = "remote = $remoteURL\nbranch = $currentBranch\nsha = $sha\n";

			$webroot->writeFile($gitRemoteFile, $content);

			return true;
		}
		return false;
	}
}

/**
 * Load an .sspak into an environment.
 * Does not backup - be careful!
 */
class Action_load {
	function go($args, $executor) {
		// Set-up
		$file = $args->unnamed(0);
		$sspak = new SSPakFile($file, $executor);
		$webroot = new Webroot($args->unnamed(1), $executor);
		$webroot->setSudo($args->sudo('to'));
		$pakParts = $args->pakParts();

		// Validation
		if(!file_exists($file)) throw new Exception( "File '$file' doesn't exist.");

		// Ensure the pakfile is on the destination server
		// If local, we can just use the sspak file directly
		if($webroot->isLocal()) {
			$sspakFile = $file;

		} else {
			// Give a name for sspakFile /tmp
			$sspakFile = "/tmp/sspak-" . rand(100000,999999) . ".sspak";

			// Upload the sspak file
			$webroot->upload($file, $sspakFile);
		}

		// Push database, if necessary
		if($pakParts['db'] && $sspak->contains('database.sql.gz')) {
			$webroot->putdb($sspakFile);
		}

		// Push assets, if neccessary
		if($pakParts['assets'] && $sspak->contains('assets.tar.gz')) {
			$webroot->putassets($sspakFile);
		}

		// Remove sspak from the server
		if($sspakFile != $file) $webroot->unlink($sspakFile);
	}
}


/**
 * Install an .sspak into a new environment.
 */
class Action_install {
	function go($args, $executor) {
		// Set-up
		$file = $args->unnamed(0);
		$webrootDir = $args->unnamed(1);
		$sspak = new SSPakFile($file, $executor);
		$webroot = new Webroot($webrootDir, $executor);
		$webroot->setSudo($args->sudo('to'));
		$pakParts = $args->pakParts();

		// Validation
		if($webroot->exists($webroot->getPath())) throw new Exception( "Webroot '$webrootDir' already exists.");
		if(!file_exists($file)) throw new Exception( "File '$file' doesn't exist.");

		// Create new dir
		$webroot->exec(array('mkdir', $webroot->getPath()));

		if($sspak->contains('git-remote')) {
			$details = $sspak->gitRemoteDetails();
			$webroot->putgit($details);
		}

		// Ensure the pakfile is on the destination server
		// If local, we can just use the sspak file directly
		if($webroot->isLocal()) {
			$sspakFile = $file;

		} else {
			// Give a name for sspakFile /tmp
			$sspakFile = "/tmp/sspak-" . rand(100000,999999) . ".sspak";

			// Upload the sspak file
			$webroot->upload($file, $sspakFile);
		}

		// Push database, if necessary
		if($pakParts['db'] && $sspak->contains('database.sql.gz')) {
			$webroot->putdb($sspakFile);
		}

		// Push assets, if neccessary
		if($pakParts['assets'] && $sspak->contains('assets.tar.gz')) {
			$webroot->putassets($sspakFile);
		}

		// Remove sspak from the server
		if($sspakFile != $file) $webroot->unlink($sspakFile);
	}
}

/**
 * Transfer between environments without creating an sspak file
 */
class Action_transfer {
	function go($args) {
		echo "Not implemented yet.\n";
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class FilesystemEntity {
	protected $server;
	protected $path;
	protected $executor;

	function __construct($path, $executor) {
		$this->executor = $executor;

		if(strpos($path,':') !== false) {
			list($this->server,$this->path) = explode(':', $path, 2);
		} else {
			$this->server = null;
			$this->path = $path;
		}
	}

	function isLocal() {
		return $this->server == null;
	}

	function getPath() {
		return $this->path;
	}

	/**
	 * Execute a command on the relevant server
	 * @param  string $command Shell command, either a fully escaped string or an array
	 */
	function exec($command, $options = array()) {
		if($this->server) return $this->executor->execRemote($this->server, $command, $options);
		else return $this->executor->execLocal($command, $options);
	}

	/**
	 * Upload a file to the given destination on the server
	 * @param string $file The file to upload
	 * @param string $dest The remote filename/dir to upload to
	 */
	function upload($source, $dest) {
		if($this->server) {
			$this->executor->execLocal(array("scp", $source, "$this->server:$dest"));
		} else {
			$this->executor->execLocal(array("cp", $source, $dest));
		}
	}

	/**
	 * Download a file from the given source on the server to the given file
	 * @param string $source The remote filename to download
	 * @param string $dest The local filename/dir to download to
	 */
	function download($source, $dest) {
		if($this->server) {
			$this->executor->execLocal(array("scp", "$this->server:$source", $dest));
		} else {
			$this->executor->execLocal(array("cp", $file, $dest));
		}
	}

	/**
	 * Returns true if the given file or directory exists
	 * @param string $file The file/dir to look for
	 * @return boolean
	 */
	function exists($file) {
		if($this->server) {
			$result = $this->execRemote($this->server, "if [ -e " . escapeshellarg($file) . " ]; then echo yes; fi");
			return (trim($result['output']) == 'yes');

		} else {
			return file_exists($file);
		}
	}

	/**
	 * Create the given file with the given content
	 */
	function writeFile($file, $content) {
		if($this->server) {
			$this->execRemote($this->server, "echo " . escapeshellarg($content) . " > " . escapeshellarg($file));

		} else {
			file_put_contents($file, $content);
		}
	}

	/**
	 * Remove a file or folder from the webroot's server
	 * 
	 * @param string $file The file to remove
	 */
	function unlink($file) {
		if(!$file || $file == '/' || $file == '.') throw new Exception("Can't unlink file '$file'");
		$this->exec(array('rm', '-rf', $file));
		return true;
	}
}

class SSPakFile extends FilesystemEntity {

	/**
	 * Returns true if this sspak file contains the given file.
	 * @param string $file The filename to look for
	 * @return boolean
	 */
	function contains($file) {
		$contents = $this->exec(array('tar', 'tf', $this->path));
		$items = explode("\n", trim($contents['output']));
		foreach($items as $item) if ($item == $file) return true;
		return false;
	}

	/**
	 * Returns the content of a file from this sspak
	 */
	function content($file) {
		$result = $this->exec(array("tar", "Oxf", $this->path, "--include", $file));
		return $result['output'];
	}

	/**
	 * Extracts the git remote details and reutrns them as a map
	 */
	function gitRemoteDetails() {
		$content = $this->content('git-remote');
		$details = array();
		foreach(explode("\n", trim($content)) as $line) {
			if(!$line) continue;

			if(preg_match('/^([^ ]+) *= *(.*)$/', $line, $matches)) {
				$details[$matches[1]] = $matches[2];
			} else {
				throw new Exception("Bad line '$line'");
			}
		}
		return $details;
	}

}

/**
 * Represents one webroot, local or remote, that sspak interacts with
 */
class Webroot extends FilesystemEntity {
	protected $sudo = null;
	protected $details = null;

	function setSudo($sudo) {
		$this->sudo = $sudo;
	}

	/**
	 * Return a map of the db & asset config details.
	 * Calls sniff once and then caches
	 */
	function details() {
		if(!$this->details) $this->details = $this->sniff();
		return $this->details;
	}

	/**
	 * Return a map of the db & asset config details, acquired with ssnap-sniffer
	 */
	function sniff() {
		$snifferFile = dirname(__FILE__) . '/sspak-sniffer.php';

		if($this->server) {
			$remoteSniffer = '/tmp/sspak-sniffer-' . rand(100000,999999) . '.php';
			$this->upload($snifferFile, $remoteSniffer);
			$result = $this->execSudo(array('/usr/bin/env', 'php', $remoteSniffer, $this->path));
			$this->unlink($remoteSniffer);

		} else {
			$result = $this->exec(array('/usr/bin/env', 'php', $snifferFile, $this->path));
		}

		$parsed = @unserialize($result['output']);
		if(!$parsed) throw new Exception("Could not parse sspak-sniffer content:\n{$result['output']}\n");
		return $parsed;
	}

	/**
	 * Execute a command on the relevant server, using the given sudo option
	 * @param  string $command Shell command, either a fully escaped string or an array
	 */
	function execSudo($command) {
		if($this->sudo) {
			if(is_array($command)) $command = $this->executor->commandArrayToString($command);
			// Try running sudo without asking for a password
			try {
				return $this->exec("sudo -n -u " . escapeshellarg($this->sudo) . " " . $command);

			// Otherwise capture SUDO password ourselves and pass it in through STDIN
			} catch(Exception $e) {
				echo "[sspak sudo] Enter your password: ";
				$stdin = fopen( 'php://stdin', 'r');
				$password = fgets($stdin);

				return $this->exec("sudo -S -p '' -u " . escapeshellarg($this->sudo) . " " . $command, array('inputContent' => $password));
			}
		
		} else {
			return $this->exec($command);
		}
	}

	/**
	 * Put the database from the given sspak file into this webroot.
	 * @param array $details The previously sniffed details of this webroot
	 * @param string $sspakFile Filename
	 */
	function putdb($sspakFile) {
		$details = $this->details();

		// Check the database type
		$dbFunction = 'putdb_'.$details['db_type'];
		if(!method_exists($this,$dbFunction)) {
			throw new Exception("Can't process database type '" . $details['db_type'] . "'");
		}

		// Extract DB direct from sspak file
		return $this->$dbFunction($details, $sspakFile);
	}

	function putdb_MySQLDatabase($conf, $sspakFile) {
		$usernameArg = escapeshellarg("--user=".$conf['db_username']);
		$passwordArg = escapeshellarg("--password=".$conf['db_password']);
		$databaseArg = escapeshellarg($conf['db_database']);
		$hostArg = (!empty($conf['db_server']) && $conf['db_server'] != 'localhost') ? escapeshellarg("--host=".$conf['db_server']) : '';
		$sspakFileArg = escapeshellarg($sspakFile);

		$this->exec("echo 'create database if not exists `" . addslashes($conf['db_database']) . "`' | mysql $usernameArg $passwordArg $hostArg");
		return $this->exec("tar Oxf $sspakFileArg --include database.sql.gz | gunzip -c | mysql --default-character-set=utf8 $usernameArg $passwordArg $hostArg $databaseArg");
	}

	function putdb_PostgreSQLDatabase($conf, $sspakFile) {
		$usernameArg = escapeshellarg("--username=".$conf['db_username']);
		$passwordArg = "PGPASSWORD=".escapeshellarg($conf['db_password']);
		$databaseArg = escapeshellarg($conf['db_database']);
		$hostArg = escapeshellarg("--host=".$conf['db_server']);
		$sspakFileArg = escapeshellarg($sspakFile);

		// Create database if needed
		$result = $this->exec("echo \"select count(*) from pg_catalog.pg_database where datname = $databaseArg\" | $passwordArg psql $usernameArg $hostArg $databaseArg -qt");
		if(trim($result['output']) == '0') {
			$this->exec("$passwordArg createdb $usernameArg $hostArg $databaseArg");
		}
		
		return $this->exec("tar Oxf $sspakFileArg --include database.sql.gz | gunzip -c | $passwordArg psql $usernameArg $hostArg $databaseArg");
	}

	function putassets($sspakFile) {
		$details = $this->details();
		$assetsPath = $details['assets_path'];

		$assetsParentArg = escapeshellarg(dirname($assetsPath));
		$assetsBaseArg = escapeshellarg(basename($assetsPath));
		$assetsBaseOldArg = escapeshellarg(basename($assetsPath).'.old');
		$sspakFileArg = escapeshellarg($sspakFile);

		// Move existing assets to assets.old
		$this->exec("if [ -d $assetsBaseArg ]; then mv $assetsBaseArg $assetsBaseOldArg; fi");

		// Extract assets
		$this->exec("tar Oxf $sspakFileArg --include assets.tar.gz | tar xzf - -C $assetsParentArg");

		// Remove assets.old
		$this->exec("if [ -d $assetsBaseOldArg ]; then rm -rf $assetsBaseOldArg; fi");
	}

	/**
	 * Load a git remote into this webroot.
	 * It expects that this remote is an empty directory.
	 * 
	 * @param array $details Map of git details
	 */
	function putgit($details) {
		$this->exec(array('git', 'clone', $details['remote'], $this->path));
		$this->exec("cd $this->path && git checkout " . escapeshellarg($details['branch']));
		return true;
	}
}

/*
 * Responsible for executing commands
 */
class Executor {
	protected $defaultOptions = array(
		'throwException' => true,
		'inputContent' => null,
		'inputFile' => null,
		'outputFile' => null,
	);

	/**
	 * @param string $command The command
	 * @param boolean $throwException If true, an Exception will be thrown on a nonzero error code
	 * @param boolean $returnOutput If true, output will be captured
	 * @param boolean $inputContent Content for STDIN. Otherwise the parent script's STDIN is used
	 * @return A map containing 'return', 'output', and 'error'
	 */
	function execLocal($command, $options = array()) {
		$options = array_merge($this->defaultOptions, $options);

		if(is_array($command)) $command = $this->commandArrayToString($command);

		$pipes = array();
		$pipeSpec = array(
			0 => STDIN,
			1 => array('pipe', 'w'),
			2 => STDERR,
		);

		// Alternatives
		if($options['inputContent']) $pipeSpec[0] = array('pipe', 'r');
		if($options['outputFile']) $pipeSpec[1] = array('file', $options['outputFile'], 'w');

		$process = proc_open($command, $pipeSpec, $pipes);

		if($options['inputContent']) fwrite($pipes[0], $options['inputContent']);
	
		$result = array();

		if(isset($pipes[1])) {
			$result['output'] = stream_get_contents($pipes[1]);
			fclose($pipes[1]);
		}
		if(isset($pipes[2])) {
			$result['error'] = stream_get_contents($pipes[2]);
			fclose($pipes[2]);
		}

		$result['return'] = proc_close($process);

		if($options['throwException'] && $result['return'] != 0)	{
			throw new Exception("Command: $command\nExecution failed: returned {$result['return']}.\n"
				. (empty($result['output']) ? "" : "Output:\n{$result['output']}"));
		}

		return $result;
	}

	function execRemote($server, $command, $options = array()) {
		if(is_array($command)) $command = $this->commandArrayToString($command);

		if(!empty($options['outputFile'])) return $this->execLocal(array("ssh", $server, $command), $options);
		else return $this->execLocal(array("ssh", "-t", $server, $command), $options);
	}

	/**
	 * Turn an array command in a string, escaping and concatenating each item
	 * @param array $command Command array. First element is the command and all remaining are the arguments.
	 * @return string String command
	 */
	function commandArrayToString($command) {
		$string = escapeshellcmd(array_shift($command));
		foreach($command as $arg) {
			$string .= ' ' . escapeshellarg($arg);
		}
		return $string;
	}

}