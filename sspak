#!/usr/bin/env php
<?php

// Process arguments into namedArgs and unnamedArgs
$args = $_SERVER['argv'];
array_shift($args);

$namedArgs = array();
$unnamedArgs = array();
$nextArgName = null;
foreach($args as $arg) {
	if($nextArgName) {
		$namedArgs[$nextArgName] = $arg;
		$nextArgName = null;
	} else {
		if(preg_match('/^--([^=]+)=(.*)$/', $arg, $matches)) {
			$namedArgs[$matches[0]] = $matches[1];
		} else if(preg_match('/^--([^=]+)$/', $arg, $matches)) {
			$nextArgName = $matches[1];
		} else {
			$unnamedArgs[] = $arg;
		}
	}
}

if(sizeof($unnamedArgs) != 3) {
	echo "Usage: {$_SERVER['argv'][0]} (action) (from) (to)\n\nAction can be 'save', 'load', or 'transfer'.\n";
	exit(1);
}

$action = array_shift($unnamedArgs);

// Action dispatch - one class per action
$actionClass = 'Action_'.strtolower($action);
if(class_exists($actionClass)) {
	$obj = new $actionClass;
	try {
		$obj->go($unnamedArgs, $namedArgs);
	} catch(Exception $e) {
		echo $e->getMessage() . "\n";
		exit(4);
	}
} else {
	echo "Unrecognised action '$action'.\n";
	exit(3);
}

exit(0);

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Save an .sspak file
 */
class Action_save {
	function go($unnamedArgs, $namedArgs) {
		// Some set-up
		$e = new Executor;

		$webroot = new Webroot($unnamedArgs[0], $e);
		$file = $unnamedArgs[1];

		if(!empty($namedArgs['from-sudo'])) $webroot->setSudo($namedArgs['from-sudo']);
		else if(!empty($namedArgs['sudo'])) $webroot->setSudo($namedArgs['sudo']);

		// Get the environment details
		$details = $webroot->sniff();

		// Check the database type
		$dbFunction = 'getdb_'.$details['db_type'];
		if(!method_exists($this,$dbFunction)) {
			throw new Exception("Can't process database type '" . $details['db_type'] . "'");
		}

		if(file_exists($file)) throw new Exception( "File '$file' already exists.");

		// Create a build folder for the sspak file
		$buildFolder = "/tmp/sspak-" . rand(100000,999999);
		$webroot->exec(array('mkdir', $buildFolder));

		$dbFile = "$buildFolder/database.sql.gz";
		$assetsFile = "$buildFolder/assets.tar.gz";

		// Save DB
		$this->$dbFunction($webroot, $details, $dbFile);

		// Save Assets
		$this->getassets($webroot, $details['assets_path'], $assetsFile);

		// Create the sspak file
		$webroot->exec(array('tar', '-C', $buildFolder, '-cf', "$buildFolder.sspak", basename($dbFile), basename($assetsFile)));
		
		// Remove the build folder
		$webroot->unlink($buildFolder);

		// Download the sspak file
		$webroot->download("$buildFolder.sspak", $file);

		// Remove it from the server
		$webroot->unlink("$buildFolder.sspak");
	}

	function getdb_MySQLDatabase($webroot, $conf, $filename) {
		$usernameArg = escapeshellarg("--user=".$conf['db_username']);
		$passwordArg = escapeshellarg("--password=".$conf['db_password']);
		$databaseArg = escapeshellarg($conf['db_database']);
		$hostArg = (!empty($conf['db_server']) && $conf['db_server'] != 'localhost') ? escapeshellarg("--host=".$conf['db_server']) : '';
		$filenameArg = escapeshellarg($filename);

		return $webroot->exec("mysqldump $usernameArg $passwordArg $hostArg $databaseArg | gzip -c > $filenameArg");
	}

	function getassets($webroot, $assetsPath, $filename) {
		$assetsParentArg = escapeshellarg(dirname($assetsPath));
		$assetsBaseArg = escapeshellarg(basename($assetsPath));
		$filenameArg = escapeshellarg($filename);

		return $webroot->exec("cd $assetsParentArg && tar czf $filenameArg $assetsBaseArg");
	}
}

/**
 * Load an .sspak into an environment.
 * Does not backup - be careful!
 */
class Action_load {
	function go($unnamedArgs, $namedArgs) {
		// Some set-up
		$e = new Executor;

		$file = $unnamedArgs[0];
		$webroot = new Webroot($unnamedArgs[1], $e);

		if(!empty($namedArgs['to-sudo'])) $webroot->setSudo($namedArgs['to-sudo']);
		else if(!empty($namedArgs['sudo'])) $webroot->setSudo($namedArgs['sudo']);

		// Get the environment details
		$details = $webroot->sniff();

		// Check the database type
		$dbFunction = 'putdb_'.$details['db_type'];
		if(!method_exists($this,$dbFunction)) {
			throw new Exception("Can't process database type '" . $details['db_type'] . "'");
		}

		if(!file_exists($file)) throw new Exception( "File '$file' don't exist.");


		// Create a build folder for the sspak file
		$buildFolder = "/tmp/sspak-" . rand(100000,999999);
		$webroot->exec(array('mkdir', $buildFolder));

		// Upload the sspak file
		$webroot->upload($file, "$buildFolder.sspak");

		// Extract the sspak file
		$webroot->exec(array('tar', '-C', $buildFolder, '-xf', "$buildFolder.sspak"));

		$dbFile = "$buildFolder/database.sql.gz";
		$assetsFile = "$buildFolder/assets.tar.gz";

		// Extract DB
		$this->$dbFunction($webroot, $details, $dbFile);

		// Extract Assets
		$this->putassets($webroot, $details['assets_path'], $assetsFile);

		// Remove the build folder
		$webroot->unlink($buildFolder);

		// Remove sspak from the server
		$webroot->unlink("$buildFolder.sspak");
	}


	function putdb_MySQLDatabase($webroot, $conf, $filename) {
		$usernameArg = escapeshellarg("--user=".$conf['db_username']);
		$passwordArg = escapeshellarg("--password=".$conf['db_password']);
		$databaseArg = escapeshellarg($conf['db_database']);
		$hostArg = (!empty($conf['db_server']) && $conf['db_server'] != 'localhost') ? escapeshellarg("--host=".$conf['db_server']) : '';
		$filenameArg = escapeshellarg($filename);

		return $webroot->exec("gunzip -c $filenameArg | mysql $usernameArg $passwordArg $hostArg $databaseArg");
	}

	function putassets($webroot, $assetsPath, $filename) {
		$assetsParentArg = escapeshellarg(dirname($assetsPath));
		$assetsBaseArg = escapeshellarg(basename($assetsPath));
		$assetsBaseOldArg = escapeshellarg(basename($assetsPath).'.old');
		$filenameArg = escapeshellarg($filename);

		return $webroot->exec("cd $assetsParentArg && mv $assetsBaseOldArg && tar xzf $filenameArg $assetsBaseArg && rm -rf $assetsBaseOldArg");
	}

}


/**
 * Transfer between environments without creating an sspak file
 */
class Action_transfer {
	function go($unnamedArgs, $namedArgs) {
		echo "Not implemented yet.\n";
	}
}

/**
 * Represents one webroot, local or remote, that sspak interacts with
 */
class Webroot {
	protected $server;
	protected $path;
	protected $executor;
	protected $sudo = null;

	function __construct($path, $executor) {
		$this->executor = $executor;

		if(strpos($path,':') !== false) {
			list($this->server,$this->path) = explode(':', $path, 2);
		} else {
			$this->server = null;
			$this->path = $path;
		}
	}

	function setSudo($sudo) {
		$this->sudo = $sudo;
	}

	/**
	 * Return a map of the db & asset config details, acquired with ssnap-sniffer
	 */
	function sniff() {
		$snifferFile = 'sspak-sniffer.php';

		if($this->server) {
			$this->upload($snifferFile, '/tmp/sspak-sniffer.php');
			$this->exec(array('chmod', 'a+r', '/tmp/sspak-sniffer.php'));
			$result = $this->execSudo(array('/usr/bin/env', 'php', '/tmp/sspak-sniffer.php', $this->path));
			$this->exec(array('unlink', '/tmp/sspak-sniffer.php'));

		} else {
			$result = $this->exec(array('/usr/bin/env', 'php', $snifferFile, $this->path));
		}

		$parsed = @unserialize($result['output']);
		if(!$parsed) throw new Exception("Could not parse sspak-sniffer content:\n{$result['output']}\n");
		return $parsed;
	}

	/**
	 * Upload a file to the given destination on the server
	 * @param string $file The file to upload
	 * @param string $dest The remote filename/dir to upload to
	 */
	function upload($source, $dest) {
		if($this->server) {
			$this->executor->execLocal(array("scp", $source, "$this->server:$dest"));
		} else {
			$this->executor->execLocal(array("cp", $source, $dest));
		}
	}

	/**
	 * Download a file from the given source on the server to the given file
	 * @param string $source The remote filename to download
	 * @param string $dest The local filename/dir to download to
	 */
	function download($source, $dest) {
		if($this->server) {
			$this->executor->execLocal(array("scp", "$this->server:$source", $dest));
		} else {
			$this->executor->execLocal(array("cp", $file, $dest));
		}
	}

	/**
	 * Remove a file or folder from the webroot's server
	 * 
	 * @param string $file The file to remove
	 */
	function unlink($file) {
		if(!$file || $file == '/' || $file == '.') throw new Exception("Can't unlink file '$file'");
		$this->exec(array('rm', '-rf', $file));
		return true;
	}

	/**
	 * Execute a command on the relevant server
	 * @param  string $command Shell command, either a fully escaped string or an array
	 */
	function exec($command, $throwException = true, $inputContent = null) {
		if($this->server) return $this->executor->execRemote($this->server, $command, $throwException, $inputContent);
		else return $this->executor->execLocal($command, $throwException, $inputContent);
	}

	/**
	 * Execute a command on the relevant server, using the given sudo option
	 * @param  string $command Shell command, either a fully escaped string or an array
	 */
	function execSudo($command) {
		if($this->sudo) {
			if(is_array($command)) $command = $this->executor->commandArrayToString($command);
			// Try running sudo without asking for a password
			try {
				return $this->exec("sudo -n -u " . escapeshellarg($this->sudo) . " " . $command);

			// Otherwise capture SUDO password ourselves and pass it in through STDIN
			} catch(Exception $e) {
				echo "[sspak sudo] Enter your password: ";
				$stdin = fopen( 'php://stdin', 'r');
				$password = fgets($stdin);

				return $this->exec("sudo -S -p '' -u " . escapeshellarg($this->sudo) . " " . $command, true, $password);
			}
		
		} else {
			return $this->exec($command);
		}
	}
}

/*
 * Responsible for executing commands
 */
class Executor {
	/**
	 * Turn a command into a sudo command
	 */
	function makeSudoCommand($command, $sudoUser) {
	}

	/**
	 * @param string $command The command
	 * @param boolean $throwException If true, an Exception will be thrown on a nonzero error code
	 * @param boolean $returnOutput If true, output will be captured
	 * @param boolean $inputContent Content for STDIN. Otherwise the parent script's STDIN is used
	 * @return A map containing 'return', 'output', and 'error'
	 */
	function execLocal($command, $throwException = true, $inputContent = null) {
		if(is_array($command)) $command = $this->commandArrayToString($command);

		$pipes = array();
		$pipeSpec = array(
			0 => $inputContent ? array('pipe', 'r') : STDIN,
			1 => array('pipe', 'w'),
			2 => STDERR,
		);
		$process = proc_open($command, $pipeSpec, $pipes);

		if($inputContent) fwrite($pipes[0], $inputContent);
	
		$output = stream_get_contents($pipes[1]);
		//$error = stream_get_contents($pipes[2]);

    	fclose($pipes[1]);
    	//fclose($pipes[2]);

    	$return = proc_close($process);
	
		if($throwException && $return != 0)	{
			throw new Exception("Command: $command\nExecution failed: returned $return.\n"
				. "Output:\n$output");
		}

    	return array(
    		'return' => $return,
    		'output' => $output,
    		//'error' => $error,
    	);
	}

	function execRemote($server, $command, $throwException = true, $inputContent = null) {
		if(is_array($command)) $command = $this->commandArrayToString($command);

		return $this->execLocal(array("ssh", "-t", $server, $command), $throwException, $inputContent);
	}

	/**
	 * Turn an array command in a string, escaping and concatenating each item
	 * @param array $command Command array. First element is the command and all remaining are the arguments.
	 * @return string String command
	 */
	function commandArrayToString($command) {
		$string = escapeshellcmd(array_shift($command));
		foreach($command as $arg) {
			$string .= ' ' . escapeshellarg($arg);
		}
		return $string;
	}

}