#!/usr/bin/env php
<?php

// Process arguments into namedArgs and unnamedArgs
$args = $_SERVER['argv'];
array_shift($args);

$namedArgs = array();
$unnamedArgs = array();
$nextArgName = null;
foreach($args as $arg) {
	if($nextArgName) {
		$namedArgs[$nextArgName] = $arg;
		$nextArgName = null;
	} else {
		if(preg_match('/^--([^=]+)=(.*)$/', $arg, $matches)) {
			$namedArgs[$matches[0]] = $matches[1];
		} else if(preg_match('/^--([^=]+)$/', $arg, $matches)) {
			$nextArgName = $matches[1];
		} else {
			$unnamedArgs[] = $arg;
		}
	}
}

if(sizeof($unnamedArgs) != 3) {
	echo "Usage: {$_SERVER['argv'][0]} (action) (from) (to)\n\nAction can be 'save', 'load', or 'transfer'.\n";
	exit(1);
}

$action = array_shift($unnamedArgs);

// Action dispatch - one class per action
$actionClass = 'Action_'.strtolower($action);
if(class_exists($actionClass)) {
	$obj = new $actionClass;
	try {
		$obj->go($unnamedArgs, $namedArgs);
	} catch(Exception $e) {
		echo $e->getMessage() . "\n";
		exit(4);
	}
} else {
	echo "Unrecognised action '$action'.\n";
	exit(3);
}

exit(0);

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Save an .sspak file
 */
class Action_save {
	function go($unnamedArgs, $namedArgs) {
		// Some set-up
		$e = new Executor;

		$webroot = new Webroot($unnamedArgs[0], $e);
		$file = $unnamedArgs[1];

		if(!empty($namedArgs['from-sudo'])) $webroot->setSudo($namedArgs['from-sudo']);
		else if(!empty($namedArgs['sudo'])) $webroot->setSudo($namedArgs['sudo']);

		// Get the environment details
		$details = $webroot->sniff();

		// Check the database type
		$dbFunction = 'getdb_'.$details['db_type'];
		if(!method_exists($this,$dbFunction)) {
			throw new Exception("Can't process database type '" . $details['db_type'] . "'");
		}

		if(file_exists($file)) throw new Exception( "File '$file' already exists.");

		// Create a build folder for the sspak file
		$buildFolder = "/tmp/sspak-" . rand(100000,999999);
		$webroot->exec(array('mkdir', $buildFolder));

		$dbFile = "$buildFolder/database.sql.gz";
		$assetsFile = "$buildFolder/assets.tar.gz";

		// Save DB
		$this->$dbFunction($webroot, $details, $dbFile);

		// Save Assets
		$this->getassets($webroot, $details['assets_path'], $assetsFile);

		// Create the sspak file
		$webroot->exec(
			array('tar', '-C', $buildFolder, '-c', '-f','-', basename($dbFile), basename($assetsFile)),
			array('outputFile' => $file)
		);
		
		// Remove the build folder
		$webroot->unlink($buildFolder);
	}

	function getdb_MySQLDatabase($webroot, $conf, $filename) {
		$usernameArg = escapeshellarg("--user=".$conf['db_username']);
		$passwordArg = escapeshellarg("--password=".$conf['db_password']);
		$databaseArg = escapeshellarg($conf['db_database']);
		$hostArg = (!empty($conf['db_server']) && $conf['db_server'] != 'localhost') ? escapeshellarg("--host=".$conf['db_server']) : '';
		$filenameArg = escapeshellarg($filename);

		return $webroot->exec("mysqldump --skip-opt --add-drop-table --extended-insert --create-options --quick  --set-charset --default-character-set=utf8 $usernameArg $passwordArg $hostArg $databaseArg | gzip -c > $filenameArg");
	}

	function getdb_PostgreSQLDatabase($webroot, $conf, $filename) {
		$usernameArg = escapeshellarg("--username=".$conf['db_username']);
		$passwordArg = "PGPASSWORD=".escapeshellarg($conf['db_password']);
		$databaseArg = escapeshellarg($conf['db_database']);
		$hostArg = escapeshellarg("--host=".$conf['db_server']);
		$filenameArg = escapeshellarg($filename);

		return $webroot->exec("$passwordArg pg_dump --clean $usernameArg $hostArg $databaseArg | gzip -c > $filenameArg");
	}

	function getassets($webroot, $assetsPath, $filename) {
		$assetsParentArg = escapeshellarg(dirname($assetsPath));
		$assetsBaseArg = escapeshellarg(basename($assetsPath));
		$filenameArg = escapeshellarg($filename);

		return $webroot->exec("cd $assetsParentArg && tar czf $filenameArg $assetsBaseArg");
	}
}

/**
 * Load an .sspak into an environment.
 * Does not backup - be careful!
 */
class Action_load {
	function go($unnamedArgs, $namedArgs) {
		// Some set-up
		$e = new Executor;

		$file = $unnamedArgs[0];
		$webroot = new Webroot($unnamedArgs[1], $e);

		if(!empty($namedArgs['to-sudo'])) $webroot->setSudo($namedArgs['to-sudo']);
		else if(!empty($namedArgs['sudo'])) $webroot->setSudo($namedArgs['sudo']);

		// Get the environment details
		$details = $webroot->sniff();

		// Check the database type
		$dbFunction = 'putdb_'.$details['db_type'];
		if(!method_exists($this,$dbFunction)) {
			throw new Exception("Can't process database type '" . $details['db_type'] . "'");
		}

		if(!file_exists($file)) throw new Exception( "File '$file' don't exist.");

		// If local, we can just use the sspak file directly
		if($webroot->isLocal()) {
			$sspakFile = $file;

		} else {
			// Give a name for sspakFile /tmp
			$sspakFile = "/tmp/sspak-" . rand(100000,999999) . ".sspak";

			// Upload the sspak file
			$webroot->upload($file, $sspakFile);
		}

		// Extract DB direct from sspak file
		$this->$dbFunction($webroot, $details, $sspakFile);

		// Extract Assets direct from sspak file
		$this->putassets($webroot, $details['assets_path'], $sspakFile);

		// Remove sspak from the server
		if($sspakFile != $file) $webroot->unlink($sspakFile);
	}


	function putdb_MySQLDatabase($webroot, $conf, $sspakFile) {
		$usernameArg = escapeshellarg("--user=".$conf['db_username']);
		$passwordArg = escapeshellarg("--password=".$conf['db_password']);
		$databaseArg = escapeshellarg($conf['db_database']);
		$hostArg = (!empty($conf['db_server']) && $conf['db_server'] != 'localhost') ? escapeshellarg("--host=".$conf['db_server']) : '';
		$sspakFileArg = escapeshellarg($sspakFile);

		$webroot->exec("echo 'create database if not exists `" . addslashes($conf['db_database']) . "`' | mysql $usernameArg $passwordArg $hostArg");
		return $webroot->exec("tar Oxf $sspakFileArg --include database.sql.gz | gunzip -c | mysql --default-character-set=utf8 $usernameArg $passwordArg $hostArg $databaseArg");
	}

	function putdb_PostgreSQLDatabase($webroot, $conf, $sspakFile) {
		$usernameArg = escapeshellarg("--username=".$conf['db_username']);
		$passwordArg = "PGPASSWORD=".escapeshellarg($conf['db_password']);
		$databaseArg = escapeshellarg($conf['db_database']);
		$hostArg = escapeshellarg("--host=".$conf['db_server']);
		$sspakFileArg = escapeshellarg($sspakFile);

		// Create database if needed
		$result = $webroot->exec("echo \"select count(*) from pg_catalog.pg_database where datname = $databaseArg\" | $passwordArg psql $usernameArg $hostArg $databaseArg -qt");
		if(trim($result['output']) == '0') {
			$webroot->exec("$passwordArg createdb $usernameArg $hostArg $databaseArg");
		}
		
		return $webroot->exec("tar Oxf $sspakFileArg --include database.sql.gz | gunzip -c | $passwordArg psql $usernameArg $hostArg $databaseArg");
	}

	function putassets($webroot, $assetsPath, $sspakFile) {
		$assetsParentArg = escapeshellarg(dirname($assetsPath));
		$assetsBaseArg = escapeshellarg(basename($assetsPath));
		$assetsBaseOldArg = escapeshellarg(basename($assetsPath).'.old');
		$sspakFileArg = escapeshellarg($sspakFile);

		// Move existing assets to assets.old
		$webroot->exec("if [ -d $assetsBaseArg ]; then mv $assetsBaseArg $assetsBaseOldArg; fi");

		// Extract assets
		$webroot->exec("tar Oxf $sspakFileArg --include assets.tar.gz | tar xzf - -C $assetsParentArg");

		// Remove assets.old
		$webroot->exec("if [ -d $assetsBaseOldArg ]; then rm -rf $assetsBaseOldArg; fi");
	}

}


/**
 * Transfer between environments without creating an sspak file
 */
class Action_transfer {
	function go($unnamedArgs, $namedArgs) {
		echo "Not implemented yet.\n";
	}
}

/**
 * Represents one webroot, local or remote, that sspak interacts with
 */
class Webroot {
	protected $server;
	protected $path;
	protected $executor;
	protected $sudo = null;

	function __construct($path, $executor) {
		$this->executor = $executor;

		if(strpos($path,':') !== false) {
			list($this->server,$this->path) = explode(':', $path, 2);
		} else {
			$this->server = null;
			$this->path = $path;
		}
	}

	function setSudo($sudo) {
		$this->sudo = $sudo;
	}

	function isLocal() {
		return $this->server == null;
	}

	/**
	 * Return a map of the db & asset config details, acquired with ssnap-sniffer
	 */
	function sniff() {
		$snifferFile = dirname(__FILE__) . '/sspak-sniffer.php';

		if($this->server) {
			$this->upload($snifferFile, '/tmp/sspak-sniffer.php');
			// This makes it easier for repeat users to clean it up
			$this->exec(array('chmod', '0777', '/tmp/sspak-sniffer.php'));
			$result = $this->execSudo(array('/usr/bin/env', 'php', '/tmp/sspak-sniffer.php', $this->path));
			$this->exec(array('unlink', '/tmp/sspak-sniffer.php'));

		} else {
			$result = $this->exec(array('/usr/bin/env', 'php', $snifferFile, $this->path));
		}

		$parsed = @unserialize($result['output']);
		if(!$parsed) throw new Exception("Could not parse sspak-sniffer content:\n{$result['output']}\n");
		return $parsed;
	}

	/**
	 * Upload a file to the given destination on the server
	 * @param string $file The file to upload
	 * @param string $dest The remote filename/dir to upload to
	 */
	function upload($source, $dest) {
		if($this->server) {
			$this->executor->execLocal(array("scp", $source, "$this->server:$dest"));
		} else {
			$this->executor->execLocal(array("cp", $source, $dest));
		}
	}

	/**
	 * Download a file from the given source on the server to the given file
	 * @param string $source The remote filename to download
	 * @param string $dest The local filename/dir to download to
	 */
	function download($source, $dest) {
		if($this->server) {
			$this->executor->execLocal(array("scp", "$this->server:$source", $dest));
		} else {
			$this->executor->execLocal(array("cp", $file, $dest));
		}
	}

	/**
	 * Remove a file or folder from the webroot's server
	 * 
	 * @param string $file The file to remove
	 */
	function unlink($file) {
		if(!$file || $file == '/' || $file == '.') throw new Exception("Can't unlink file '$file'");
		$this->exec(array('rm', '-rf', $file));
		return true;
	}

	/**
	 * Execute a command on the relevant server
	 * @param  string $command Shell command, either a fully escaped string or an array
	 */
	function exec($command, $options = array()) {
		if($this->server) return $this->executor->execRemote($this->server, $command, $options);
		else return $this->executor->execLocal($command, $options);
	}

	/**
	 * Execute a command on the relevant server, using the given sudo option
	 * @param  string $command Shell command, either a fully escaped string or an array
	 */
	function execSudo($command) {
		if($this->sudo) {
			if(is_array($command)) $command = $this->executor->commandArrayToString($command);
			// Try running sudo without asking for a password
			try {
				return $this->exec("sudo -n -u " . escapeshellarg($this->sudo) . " " . $command);

			// Otherwise capture SUDO password ourselves and pass it in through STDIN
			} catch(Exception $e) {
				echo "[sspak sudo] Enter your password: ";
				$stdin = fopen( 'php://stdin', 'r');
				$password = fgets($stdin);

				return $this->exec("sudo -S -p '' -u " . escapeshellarg($this->sudo) . " " . $command, array('inputContent' => $password));
			}
		
		} else {
			return $this->exec($command);
		}
	}
}

/*
 * Responsible for executing commands
 */
class Executor {
	protected $defaultOptions = array(
		'throwException' => true,
		'inputContent' => null,
		'inputFile' => null,
		'outputFile' => null,
	);

	/**
	 * @param string $command The command
	 * @param boolean $throwException If true, an Exception will be thrown on a nonzero error code
	 * @param boolean $returnOutput If true, output will be captured
	 * @param boolean $inputContent Content for STDIN. Otherwise the parent script's STDIN is used
	 * @return A map containing 'return', 'output', and 'error'
	 */
	function execLocal($command, $options = array()) {
		$options = array_merge($this->defaultOptions, $options);

		if(is_array($command)) $command = $this->commandArrayToString($command);

		$pipes = array();
		$pipeSpec = array(
			0 => STDIN,
			1 => array('pipe', 'w'),
			2 => STDERR,
		);

		// Alternatives
		if($options['inputContent']) $pipeSpec[0] = array('pipe', 'r');
		if($options['outputFile']) $pipeSpec[1] = array('file', $options['outputFile'], 'w');

		$process = proc_open($command, $pipeSpec, $pipes);

		if($options['inputContent']) fwrite($pipes[0], $options['inputContent']);
	
		$result = array();

		if(isset($pipes[1])) {
			$result['output'] = stream_get_contents($pipes[1]);
			fclose($pipes[1]);
		}
		if(isset($pipes[2])) {
			$result['error'] = stream_get_contents($pipes[2]);
			fclose($pipes[2]);
		}

		$result['return'] = proc_close($process);

		if($options['throwException'] && $result['return'] != 0)	{
			throw new Exception("Command: $command\nExecution failed: returned {$result['return']}.\n"
				. "Output:\n{$result['output']}");
		}

		return $result;
	}

	function execRemote($server, $command, $options = array()) {
		if(is_array($command)) $command = $this->commandArrayToString($command);

		if(!empty($options['outputFile'])) return $this->execLocal(array("ssh", $server, $command), $options);
		else return $this->execLocal(array("ssh", "-t", $server, $command), $options);
	}

	/**
	 * Turn an array command in a string, escaping and concatenating each item
	 * @param array $command Command array. First element is the command and all remaining are the arguments.
	 * @return string String command
	 */
	function commandArrayToString($command) {
		$string = escapeshellcmd(array_shift($command));
		foreach($command as $arg) {
			$string .= ' ' . escapeshellarg($arg);
		}
		return $string;
	}

}